import io
import itertools
import json
import os
import re
import shutil
import subprocess
from collections import defaultdict, OrderedDict
from typing import Any, Dict, List, Optional, Tuple

import numpy as np
import pandas as pd
import yaml
from maml.apps.pes import MTPotential
from maml.utils import check_structures_forces_stresses, pool_from
from monty.io import zopen
from monty.tempfile import ScratchDir
from pymatgen.core import Lattice, Structure
from sklearn.metrics import mean_absolute_error


# TODO list of yaml files should come from an external call
# yaml dump file
lammps_yaml = ['lammps_scripts/Si/si-custom/dump.si-300-1.yaml']
# yaml thermodynamic variables
lammps_thermo_yaml = ['lammps_scripts/Si/si-custom/thermo_log.yaml']
# note that the YAML output does not contain the map from index to atomic species
# this will have to be taken from elsewhere
# use a manual map for now
atom_dict = {1: 'Si'}


def convert_to_dataframe(docs: List[Dict[str, Any]]) -> pd.DataFrame:
    """Method to convert a list of docs into DataFrame usable for computing metrics and analysis.

    Modified from maml.utils._data_conversion.py

    Args:
        docs: list of docs generated by mlip-3. Each doc should be structured as a dict.

    Returns:
        A DataFrame with energy, force, and nbh grades (MaxVol factor) per atom and per structure. Energy is repeated
        for each atom and corresponds to the total energy predicted.
    """
    # TODO move to another .py file
    df = defaultdict(list)
    for s_idx, d in enumerate(docs):
        outputs = d["outputs"]
        force_arr = np.array(outputs["forces"])
        n_atom = force_arr.shape[0]
        for i, x in enumerate(['x', 'y', 'z']):
            df[f'f{x}'] += force_arr[:, i].tolist()
        df['energy'] += [outputs['energy']] * n_atom  # copy the value to all atoms
        if "nbh_grades" in outputs.keys():
            nbh_grades = outputs["nbh_grades"]
            df['nbh_grades'] += nbh_grades
        df['atom_index'] += list(range(n_atom))
        df['structure_index'] += [s_idx] * n_atom

    df = pd.DataFrame(df)
    return df


class MTP_with_MLIP3(MTPotential):
    """MTP with MLIP-3."""
    def __init__(self,
                 mlip_path: str,
                 maml_path: str,
                 name: Optional[str] = None,
                 param: Optional[Dict[Any, Any]] = None,
                 version:Optional[str] = None):
        """Modifications to maml.apps.pes._mtp.MTPotential to be compatible with mlip-3

        Args:
            mlip_path: path to mlip3 mlp command
            maml_path: path to maml _mtp.py file
            name: MTPotential argument
            param: MTPotential argument
            version: MTPotential argument
        """
        super().__init__(name, param, version)
        self.mlp_command = mlip_path
        # TODO there is a better way to do this
        self.module_dir = maml_path
        self.fitted_mtp = None

    def to_lammps_format(self):
        # TODO
        # write params write the fitted mtp in a LAMMPS compatible format
        # self.write_param(
        #    fitted_mtp=fitted_mtp,
        #    Abinitio=0,
        #    Driver=1,
        #    Write_cfgs=predict_file,
        #    Database_filename=original_file,
        #    **kwargs,
        # )
        pass

    def evaluate(self,
                 fitted_mtp_path: str,
                 test_structures: List[Structure],
                 test_energies: List[float],
                 test_forces: List[List[float]],
                 test_stresses: Optional[List[List[float]]]=None,
    ) -> Tuple[pd.DataFrame, pd.DataFrame]:
        """
        Evaluate energies, forces, stresses and MaxVol gamma factor of structures with trained
        interatomic potentials.

        Args:
            fitted_mtp_path: path to fitted mtp file.
            test_structures: evaluation set of pymatgen Structure Objects.
            test_energies: list of total energies of each structure to evaluation in test_structures list.
            test_forces: list of calculated (m, 3) forces of each evaluation structure with m atoms in structures list.
                m can be varied with each single structure case.
            test_stresses (optional): list of calculated (6, ) virial stresses of each evaluation structure in
                test_structures list. If None, do not evaluate on stresses. Default to None.

        Returns:
            dataframe with ground truth energies, forces
            dataframe with predicted energies, forces, MaxVol gamma (nbh grades)
        """
        fitted_mtp = fitted_mtp_path
        original_file = "original.cfgs"
        predict_file = "predict.cfgs"
        test_structures, test_forces, test_stresses = check_structures_forces_stresses(
            test_structures, test_forces, test_stresses
        )
        predict_pool = pool_from(test_structures, test_energies, test_forces, test_stresses)

        with ScratchDir("."):  # mlip needs a tmp_work_dir - we will manually copy relevant outputs elsewhere
            # write the structures to evaluate in a mlp compatible format
            original_file = self.write_cfg(original_file, cfg_pool=predict_pool)
            df_orig = self.read_cfgs(original_file, nbh_grade=False)  # read original values as a DataFrame

            # calculate_grade is the method to get the forces, energy & maxvol values
            cmd = [self.mlp_command, "calculate_grade", fitted_mtp, original_file, predict_file]
            predict_file += '.0'  # added by mlp...
            with subprocess.Popen(cmd, stdout=subprocess.PIPE) as p:  # run mlp
                stdout = p.communicate()[0]
                rc = p.returncode
            if rc != 0:
                error_msg = f"mlp exited with return code {rc}"
                msg = stdout.decode("utf-8").split("\n")[:-1]
                try:
                    error_line = next(i for i, m in enumerate(msg) if m.startswith("ERROR"))
                    error_msg += ", ".join(msg[error_line:])
                except Exception:
                    error_msg += msg[-1]
                raise RuntimeError(error_msg)

            df_predict = self.read_cfgs(predict_file, nbh_grade=True)
        return df_orig, df_predict

    def read_cfgs(self, filename: str, nbh_grade: bool = False) -> pd.DataFrame:
        """Read mlp output when MaxVol gamma factor is present.

        Args:
            filename: name of mlp output file to be parsed.
            nbh_grade (optional): if True, add the nbh_grades in the resulting dataframe. Defaults to False.

        Returns:
            dataframe with energies, forces, optional nbh grades (MaxVol gamma)
        """
        def formatify(string: str) -> List[float]:
            """Utility to convert string to a list of float"""
            return [float(s) for s in string.split()]

        if not self.elements:
            raise ValueError("No species given.")

        data_pool = []
        with zopen(filename, "rt") as f:
            lines = f.read()

        block_pattern = re.compile("BEGIN_CFG\n(.*?)\nEND_CFG", re.S)
        size_pattern = re.compile("Size\n(.*?)\n SuperCell", re.S | re.I)
        if nbh_grade:
            position_pattern = re.compile("nbh_grades\n(.*?)\n Energy", re.S)
        else:
            position_pattern = re.compile("fz\n(.*?)\n Energy", re.S)
        energy_pattern = re.compile("Energy\n(.*?)\n (?=PlusStress|Stress)", re.S)
        # stress_pattern = re.compile("xy\n(.*?)(?=\n|$)", re.S)  # TODO stress values

        for block in block_pattern.findall(lines):
            d = {"outputs": {}}
            size_str = size_pattern.findall(block)[0]
            size = int(size_str.lstrip())
            position_str = position_pattern.findall(block)[0]
            position = np.array(list(map(formatify, position_str.split("\n"))))
            species = np.array(self.elements)[position[:, 1].astype(np.int64)]
            forces = position[:, 5:8].tolist()

            energy_str = energy_pattern.findall(block)[0]
            energy = float(energy_str.lstrip())
            # TODO add stress
            # stress_str = stress_pattern.findall(block)[0]
            # virial_stress = (np.array(list(map(formatify, stress_str.split()))).reshape(6,).tolist())
            # virial_stress = [virial_stress[self.mtp_stress_order.index(n)] for n in self.vasp_stress_order]
            d["outputs"]["energy"] = energy
            d["num_atoms"] = size
            d["outputs"]["forces"] = forces
            d["outputs"]["species"] = species
            # d["outputs"]["virial_stress"] = virial_stress
            if nbh_grade:
                nbh_grade_values = position[:, 8].tolist()
                d["outputs"]["nbh_grades"] = nbh_grade_values
            data_pool.append(d)

        # originally used convert_docs from maml.utils, but it hard-coded the structure of the dataframe and does not
        # manage nbh_grades; we use our own implementation instead
        df = convert_to_dataframe(docs=data_pool)
        return df

    def train(
            self,
            train_structures: List[Structure],
            train_energies: List[float],
            train_forces: List[np.array],
            train_stresses: List[List[float]],
            unfitted_mtp: str = "08g.mtp",  # TODO fix this
            fitted_mtp_savedir: str = '../',
            max_dist: float = 5,
            radial_basis_size: int = 8,
            max_iter: int = 1000,  # TODO check the next kwargs in mlip3
            energy_weight: float = 1,
            force_weight: float = 1e-2,
            stress_weight: float = 1e-3,
            init_params: str = "same",
            scale_by_force: float = 0,
            bfgs_conv_tol: float = 1e-3,
            weighting: float = "vibration",
    ) -> int:
        """Training data with moment tensor method using MLIP-3.

        Override the base class method.

        Args:
            train_structures: The list of Pymatgen Structure object.
            energies: The list of total energies of each structure in structures list.
            train_energies: List of total energies of each structure in structures list.
            train_forces: List of (m, 3) forces array of each structure with m atoms in structures list.
                m can be varied with each single structure case.
            train_stresses: List of (6, ) virial stresses of each structure in structures list.
            unfitted_mtp (optional): Define the initial mtp file.
                Default to 08g.mtp -  the mtp file stored in .params directory. TODO change
            fitted_mtp_savedir (optional): save directory for the fitted MTP. Defaults to '../' (current wd)
            max_dist (optional): The actual radial cutoff. Defaults to 5.
            radial_basis_size (optional): Relevant to number of radial basis function. Defaults to 8.
            max_iter (optional): The number of maximum iteration. Defaults to 1000.
            energy_weight (optional): The weight of energy. Defaults to 1
            force_weight (optional): The weight of forces. Defaults to 1e-2
            stress_weight (optional): The weight of stresses. Zero-weight can be assigned. Defaults to 1e-3.
            init_params (optional): How to initialize parameters if a potential was not
                pre-fitted. Choose from "same" and "random". Defaults to "same".
            scale_by_force (optional): If >0 then configurations near equilibrium
               (with roughly force < scale_by_force) get more weight. Defaults to 0.
            bfgs_conv_tol (optional): Stop training if error dropped by a factor smaller than this
                over 50 BFGS iterations. Defaults to 1e-3.
            weighting (optional): How to weight configuration with different sizes relative to each other.
                Choose from "vibrations", "molecules" and "structures". Defaults to "vibration".

        Returns:
            rc : return code of the mlp training script
        """
        train_structures, train_forces, train_stresses = check_structures_forces_stresses(
            train_structures, train_forces, train_stresses
        )
        train_pool = pool_from(train_structures, train_energies, train_forces, train_stresses)
        elements = sorted(set(itertools.chain(*[struct.species for struct in train_structures])))
        self.elements = [str(element) for element in elements]  # TODO move to __init__

        atoms_filename = "train.cfgs"

        with ScratchDir("."):  # create a tmpdir - deleted afterew
            atoms_filename = self.write_cfg(filename=atoms_filename, cfg_pool=train_pool)

            if not unfitted_mtp:
                raise RuntimeError("No specific parameter file provided.")
            # TODO move initial mtp file to our repo to remove the dependency on module_dir
            mtp_file_path = os.path.join(self.module_dir, "params", unfitted_mtp)
            shutil.copyfile(mtp_file_path, os.path.join(os.getcwd(), unfitted_mtp))
            commands = [self.mlp_command, "mindist", atoms_filename]
            with open("min_dist", "w") as f, subprocess.Popen(commands, stdout=f)  as p:
                p.communicate()[0]

            with open("min_dist") as f:
                lines = f.readlines()

            split_symbol = "="  # different for mlip-2 (":") and mlip-3 ("=")
            min_dist = float(lines[-1].split(split_symbol)[1])

            with open(unfitted_mtp) as f:
                template = f.read()

            s = template % (len(self.elements), min_dist, max_dist, radial_basis_size)
            with open(unfitted_mtp, "w") as f:
                f.write(s)

            save_fitted_mtp = ".".join([unfitted_mtp.split(".")[0] + "_fitted", unfitted_mtp.split(".")[1]])
            cmds_list = [
                self.mlp_command,
                "train",
                unfitted_mtp,
                atoms_filename,
                f"--save_to={save_fitted_mtp}",
                f"--iteration_limit={max_iter}",
                "--al_mode=nbh",  # active learning mode - required to get extrapolation grade
                # f"--curr-pot-name={unfitted_mtp}",  # TODO check those kwargs
                #f"--energy-weight={energy_weight}",
                #f"--force-weight={force_weight}",
                #f"--stress-weight={stress_weight}",
                #f"--init-params={init_params}",
                #f"--scale-by-force={scale_by_force}",
                #f"--bfgs-conv-tol={bfgs_conv_tol}",
                #f"--weighting={weighting}",
             ]
            with subprocess.Popen(cmds_list, stdout=subprocess.PIPE) as p:
                stdout = p.communicate()[0]
                rc = p.returncode
            if rc != 0:
                error_msg = f"MLP exited with return code {rc}"
                msg = stdout.decode("utf-8").split("\n")[:-1]
                try:
                    error_line = next(i for i, m in enumerate(msg) if m.startswith("ERROR"))
                    error_msg += ", ".join(msg[error_line:])
                except Exception:
                    error_msg += msg[-1]
                raise RuntimeError(error_msg)
            # copy the fitted mtp outside the working directory
            self.fitted_mtp = os.path.join(fitted_mtp_savedir, save_fitted_mtp)
            shutil.copy(save_fitted_mtp, self.fitted_mtp)
        return rc


def extract_structure_and_forces_from_file(filename: str, atom_dict: Dict[int, Any]) -> \
        Tuple[List[Structure], List[List[float]]]:
    """Convert LAMMPS yaml output in a format compatible with MTP training and evaluation methods.

    Args:
        filename: path to LAMMPS output file in yaml format
        atom_dict: mapping from LAMMPS atom indices to atom type (atomic number as int or atom name as str)

    Returns:
        list of pymatgen Structure containing the atoms and their positions
        list of forces (n x 3) for each atom
    """
    structures = []
    forces = []
    with (open(filename, 'r') as f):
        l_yaml = yaml.safe_load_all(f)
        for d in l_yaml:  # loop over LAMMPS outputs and convert in pymatgen Structure objects
            # lattice in yaml is 3 x 2 [0, x_lim]
            # we assume a rectangular lattice for now with the 2nd coordinates as the lattice vectors
            lattice = np.zeros((3, 3))
            for i, x in enumerate(d['box']):
                lattice[i, i] = x[1]
            type_idx = d['keywords'].index('type')
            species = [atom_dict[x[type_idx]] for x in d['data']]  # convert to atom type
            coords_idx = [d['keywords'].index(x) for x in ['x', 'y', 'z']]
            coords = [[x[i] for i in coords_idx] for x in d['data']]
            pm_structure = Structure(lattice=lattice,
                                    species=species,
                                    coords=coords)
            structures.append(pm_structure)
            force_idx = [d['keywords'].index(x) for x in ['fx', 'fy', 'fz']]
            structure_forces = [[x[i] for i in force_idx] for x in d['data']]
            forces.append(structure_forces)
    return structures, forces


def extract_energy_from_thermo_log(filename: str) -> List[float]:
    """Read energies from LAMMPS thermodynamic output file.

    Args:
        filename: path to LAMMPS thermodynamic output file in yaml format.

    Returns:
        list of energies (1 value per configuration)
    """
    with open(filename, 'r') as f:
        log_yaml = yaml.safe_load(f)
        kin_idx = log_yaml['keywords'].index('KinEng')
        pot_idx = log_yaml['keywords'].index('PotEng')
        energies = [x[kin_idx] + x[pot_idx] for x in log_yaml['data']]
    return energies


def prepare_mtp_inputs_from_lammps(output_yaml: List[str], thermo_yaml: List[str], atom_dict: Dict[int, Any]) -> \
    Dict[str, Any]:
    """Convert a list of LAMMPS output files and thermodynamic output files to MTP input format.

    Args:
        output_yaml: list of LAMMPS output files as yaml.
        thermo_yaml: list of LAMMPS thermodynamic output files as yaml.
        atom_dict: mapping of LAMMPS indices to atom type.

    Returns:
        dict with structure, energies and forces usable by MTP.
    """
    mtp_inputs = {
        'structure': [],
        'energy': [],
        'forces': []
    }
    for filename in output_yaml:
        structures, forces = extract_structure_and_forces_from_file(filename, atom_dict)
        mtp_inputs['structure'] += structures
        mtp_inputs['forces'] += forces
    for filename in thermo_yaml:
        mtp_inputs['energy'] += extract_energy_from_thermo_log(filename)
    return mtp_inputs


def train_mtp(train_inputs: Dict[str, Any], max_dist: float=5) -> MTP_with_MLIP3:
    """Create and evaluate a MTP potential.

    Args:
        train_inputs: inputs for training. Should contain structure, energies and forces
        max_dist (optional): radial cutoff. Defaults to 5.

    Returns:
       dataframe with original and predicted energies and forces.
    """
    # TODO more kwargs for MTP training. See maml documentation.
    # create MTP
    mlp_path = "/Users/simonb/ic-collab/courtois_collab/crystal_diffusion/mlip-3/build/mlp"
    maml_path = "/Users/simonb/miniconda/envs/crystal_diffusion/lib/python3.11/site-packages/maml/apps/pes/"
    mtp = MTP_with_MLIP3(mlip_path=mlp_path, maml_path=maml_path)
    # train
    mtp.train(
        train_structures=train_inputs["structure"],
        train_energies=train_inputs["energy"],
        train_forces=train_inputs["forces"],
        train_stresses=None,
        max_dist=5,
        stress_weight=0,  # TODO kwargs and savedir as args
        fitted_mtp_savedir='/Users/simonb/ic-collab/courtois_collab/crystal_diffusion/debug_mlip3/'
    )

    return mtp


def evaluate_mtp(eval_inputs: Dict[str, Any], mtp: MTP_with_MLIP3) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """Create and evaluate a MTP potential.

    Args:
        eval_inputs: inputs to evaluate. Should contain structure, energies and forces
        mtp: trained MTP potential.

    Returns:
       dataframe with original and predicted energies and forces.
    """
    # evaluate
    df_orig, df_predict = mtp.evaluate(
        fitted_mtp_path='/Users/simonb/ic-collab/courtois_collab/crystal_diffusion/debug_mlip3/08g_fitted.mtp',
        test_structures=eval_inputs["structure"],
        test_energies=eval_inputs["energy"],
        test_forces=eval_inputs["forces"],
        test_stresses=None,
    )
    return df_orig, df_predict


def get_metrics_from_pred(df_orig: pd.DataFrame, df_predict: pd.DataFrame) -> Tuple[float, float]:
    """Get mean absolute error on energy and forces from the outputs of MTP.

    Args:
        df_orig: dataframe with ground truth values
        df_predict: dataframe with MTP predictions

    Returns:
        MAE on energy in eV/atom and MAE on forces in eV/Å
    """
    # from demo in maml
    # get a single predicted energy per structure
    predicted_energy = df_predict.groupby('structure_index').agg({'energy': 'mean', 'atom_index': 'count'})
    # normalize by number of atoms
    predicted_energy = (predicted_energy['energy'] / predicted_energy['atom_index']).to_numpy()
    # same for ground truth
    gt_energy = df_orig.groupby('structure_index').agg({'energy': 'mean', 'atom_index': 'count'})
    gt_energy = (gt_energy['energy'] / gt_energy['atom_index']).to_numpy()

    predicted_forces = df_predict.groupby('structure_index').agg({'fx': 'sum', 'fy': 'sum', 'fz': 'sum',
                                                                  'atom_index': 'count'})
    predicted_forces = np.concatenate([(predicted_forces[f'f{x}'] / predicted_forces['atom_index']).to_numpy()
                                  for x in ['x', 'y', 'z']])

    gt_forces = df_orig.groupby('structure_index').agg({'fx': 'sum', 'fy': 'sum', 'fz': 'sum',
                                                                  'atom_index': 'count'})
    gt_forces = np.concatenate([(gt_forces[f'f{x}'] / gt_forces['atom_index']).to_numpy() for x in ['x', 'y', 'z']])

    return mean_absolute_error(predicted_energy, gt_energy) , mean_absolute_error(predicted_forces, gt_forces)


def main():
    mtp_inputs = prepare_mtp_inputs_from_lammps(lammps_yaml, lammps_thermo_yaml, atom_dict)
    mtp = train_mtp(mtp_inputs)
    print("Training is done")
    df_orig, df_predict = evaluate_mtp(mtp_inputs, mtp)
    energy_mae, force_mae = get_metrics_from_pred(df_orig, df_predict)
    print(f"MAE of training energy prediction is {energy_mae * 1000} meV/atom")
    print(f"MAE of training force prediction is {force_mae} eV/Å")


if __name__ == '__main__':
    main()
